using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// An NSURL object represents a URL that can potentially contain the location of a resource on a remote server, the path of a local file on disk, or even an arbitrary piece of encoded data.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURL_Class/index.html#//apple_ref/occ/cl/NSURL"/>    [iOSVersion(2)]    public class NSURL : NSObject//, AnyObject, NSCoding, NSCopying, NSObjectProtocol, NSSecureCoding, Reflectable    {        /// <summary>        /// Initializes a newly created NSURL with a specified scheme, host, and path.        /// </summary>        /// <param name="scheme">The scheme for the NSURL object. For example, in the URL http://www.example.com/index.html, the scheme is http.</param>        /// <param name="host">The host for the NSURL object (for example, www.example.com). May be the empty string.</param>        /// <param name="path">The path for the NSURL object (for example, /index.html). If the path begins with a tilde, you must first expand it by calling stringByExpandingTildeInPath.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSURL(string scheme, string host, string path) { }                /// <summary>        /// Creates and returns an NSURL object initialized with a provided URL string.        /// </summary>        /// <param name="URLString">The URL string with which to initialize the NSURL object. Must be a URL that conforms to RFC 2396. This method parses URLString according to RFCs 1738 and 1808.</param>        [iOSVersion(2)]        public static NSURL URLWithString(string URLString) { return default(NSURL); }                /// <summary>        /// Initializes an NSURL object with a provided URL string.        /// </summary>        /// <param name="@string">The URL string with which to initialize the NSURL object. This URL string must conform to URL format as described in RFC 2396, and must not be nil. This method parses URLString according to RFCs 1738 and 1808.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSURL(string @string) { }                /// <summary>        /// Creates and returns an NSURL object initialized with a base URL and a relative string.        /// </summary>        /// <param name="URLString">The URL string with which to initialize the NSURL object. May not be nil. Must conform to RFC 2396. URLString is interpreted relative to baseURL.</param>        /// <param name="relativeToURL">The base URL for the NSURL object.</param>        [iOSVersion(2)]        public static NSURL URLWithString(string URLString, NSURL relativeToURL) { return default(NSURL); }                /// <summary>        /// Initializes an NSURL object with a base URL and a relative string.        /// </summary>        /// <param name="@string">The URL string with which to initialize the NSURL object. Must conform to RFC 2396. URLString is interpreted relative to baseURL.</param>        /// <param name="relativeToURL">The base URL for the NSURL object.</param>        [iOSVersion(2)]        public NSURL(string @string, NSURL relativeToURL) { }                /// <summary>        /// Initializes and returns a newly created NSURL object as a file URL with a specified path.        /// </summary>        /// <param name="path">The path that the NSURL object will represent. path should be a valid system path. If path begins with a tilde, it must first be expanded with stringByExpandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.        ///   Passing nil for this parameter produces an exception.</param>        /// <param name="isDirectory">A Boolean value that specifies whether path is treated as a directory path when resolving against relative path components. Pass true if the path indicates a directory, false otherwise.</param>        [iOSVersion(2)]        [Export("fileURLWithPath")]        public static NSURL FileURLWithPath(string path, bool isDirectory) { return default(NSURL); }                /// <summary>        /// Initializes a newly created NSURL referencing the local file or directory at path.        /// </summary>        /// <param name="fileURLWithPath">The path that the NSURL object will represent. path should be a valid system path. If path begins with a tilde, it must first be expanded with stringByExpandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.        ///   Passing nil for this parameter produces an exception.</param>        /// <param name="isDirectory">A Boolean value that specifies whether path is treated as a directory path when resolving against relative path components. Pass true if the path indicates a directory, false otherwise</param>        [iOSVersion(2)]        public NSURL(string fileURLWithPath, bool isDirectory) { }                /// <summary>        /// Initializes and returns a newly created NSURL object as a file URL with a specified path.        /// </summary>        /// <param name="path">The path that the NSURL object will represent. path should be a valid system path. If path begins with a tilde, it must first be expanded with stringByExpandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.        ///   Passing nil for this parameter produces an exception.</param>        [iOSVersion(2)]        [Export("fileURLWithPath")]        public static NSURL FileURLWithPath(string path) { return default(NSURL); }                /// <summary>        /// Initializes a newly created NSURL referencing the local file or directory at path.        /// </summary>        /// <param name="fileURLWithPath">The path that the NSURL object will represent. path should be a valid system path. If path begins with a tilde, it must first be expanded with stringByExpandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.        ///   Passing nil for this parameter produces an exception.</param>        /// <param name="NAME_YOUR_PARAMS">DO NOT USE THIS PARAMETER - Instead make sure to name the parameters you're using.</param>        [iOSVersion(2)]        [IgnoreParameter("NAME_YOUR_PARAMS")]        public NSURL(string fileURLWithPath, int NAME_YOUR_PARAMS = 0) { }                /// <summary>        /// Initializes and returns a newly created NSURL object as a file URL with specified path components.        /// </summary>        /// <param name="components">An array of path components.        ///   Passing nil for this parameter produces an exception.</param>        [iOSVersion(4)]        [Export("fileURLWithPathComponents")]        public static NSURL FileURLWithPathComponents(AnyObject[] components) { return default(NSURL); }                /// <summary>        /// Returns a new URL made by resolving the alias file at url.        /// </summary>        /// <param name="url">The URL pointing to the alias file.</param>        /// <param name="options">Options taken into account when resolving the bookmark data. The NSURLBookmarkResolutionWithSecurityScope option is not supported by this method.</param>        /// <param name="error">The error that occurred while trying to resolve the provided URL.</param>        [iOSVersion(8)]        public static NSURL URLByResolvingAliasFileAtURL(NSURL url, NSURLBookmarkResolutionOptions options, NSErrorPointer error) { return default(NSURL); }                /// <summary>        /// Returns a new URL made by resolving bookmark data.        /// </summary>        /// <param name="bookmarkData">The bookmark data the URL is derived from.</param>        /// <param name="options">Options taken into account when resolving the bookmark data.        ///   To resolve a security-scoped bookmark to support App Sandbox, you must include (by way of bitwise OR operators with any other options in this parameter) the NSURLBookmarkResolutionWithSecurityScope option.</param>        /// <param name="relativeToURL">The base URL that the bookmark data is relative to.        ///   If you are resolving a security-scoped bookmark to obtain a security-scoped URL, use this parameter as follows:        ///   To resolve an app-scoped bookmark, use a value of nil.        ///   To resolve a document-scoped bookmark, use the absolute path (despite this parameter’s name) to the document from which you retrieved the bookmark.</param>        /// <param name="bookmarkDataIsStale">On return, if true, the bookmark data is stale. Your app should create a new bookmark using the returned URL and use it in place of any stored copies of the existing bookmark.</param>        /// <param name="error">The error that occurred in the case that the URL cannot be created.</param>        [iOSVersion(5)]        public static NSURL URLByResolvingBookmarkData(NSData bookmarkData, NSURLBookmarkResolutionOptions options, NSURL relativeToURL, UnsafePointer<ObjCBool> bookmarkDataIsStale, NSErrorPointer error) { return default(NSURL); }                /// <summary>        /// Initializes a newly created NSURL that points to a location specified by resolving bookmark data.        /// </summary>        /// <param name="byResolvingBookmarkData">The bookmark data the URL is derived from.</param>        /// <param name="options">Options taken into account when resolving the bookmark data.</param>        /// <param name="relativeToURL">The base URL that the bookmark data is relative to.</param>        /// <param name="bookmarkDataIsStale">If true, the bookmark data is stale.</param>        /// <param name="error">The error that occurred in the case that the URL cannot be created.</param>        [iOSVersion(5)]        [Export("convenience init")]        public NSURL(NSData byResolvingBookmarkData, NSURLBookmarkResolutionOptions options, NSURL relativeToURL, UnsafePointer<ObjCBool> bookmarkDataIsStale, NSErrorPointer error) { }                /// <summary>        /// Returns a new URL object initialized with a C string representing a local file system path.        /// </summary>        /// <param name="path">A null-terminated C string in file system representation containing the path to represent as a URL. If this path is a relative path, it is treated as being relative to the current working directory.</param>        /// <param name="isDirectory">true if the last path part is a directory, otherwise false.</param>        /// <param name="relativeToURL">The base URL for the new URL object. This must be a file URL. If path is absolute, this URL is ignored.</param>        [iOSVersion(7)]        [Export("fileURLWithFileSystemRepresentation")]        public static NSURL FileURLWithFileSystemRepresentation(ConstUnsafePointer<Int8> path, bool isDirectory, NSURL relativeToURL) { return default(NSURL); }                /// <summary>        /// Fills the provided buffer with a C string representing a local file system path.        /// </summary>        /// <param name="buffer">A buffer large enough to hold the path. On return, contains a null-terminated C string in file system representation.</param>        /// <param name="maxLength">The size of buffer in bytes (typically MAXPATHLEN or PATH_MAX).</param>        [iOSVersion(7)]        [Export("getFileSystemRepresentation")]        public bool GetFileSystemRepresentation(UnsafePointer<Int8> buffer, int maxLength) { return default(bool); }                /// <summary>        /// Initializes a URL object with a C string representing a local file system path.        /// </summary>        /// <param name="fileURLWithFileSystemRepresentation">A null-terminated C string in file system representation containing the path to represent as a URL. If this path is a relative path, it is treated as being relative to the current working directory.</param>        /// <param name="isDirectory">true if the last path part is a directory, otherwise false.</param>        /// <param name="relativeToURL">The base URL for the new URL object. This must be a file URL. If path is absolute, this URL is ignored.</param>        [iOSVersion(7)]        public NSURL(ConstUnsafePointer<Int8> fileURLWithFileSystemRepresentation, bool isDirectory, NSURL relativeToURL) { }                /// <summary>        /// Returns whether the resource pointed to by a file URL can be reached.        /// </summary>        /// <param name="error">The error that occurred when the resource could not be reached.</param>        [iOSVersion(5)]        [Export("checkResourceIsReachableAndReturnError")]        public bool CheckResourceIsReachableAndReturnError(NSErrorPointer error) { return default(bool); }                /// <summary>        /// Returns whether the URL is a file reference URL.        /// </summary>        [iOSVersion(5)]        [Export("isFileReferenceURL")]        public bool IsFileReferenceURL() { return default(bool); }                /// <summary>        /// Returns a new file reference URL that points to the same resource as the receiver.        /// </summary>        [iOSVersion(5)]        [Export("fileReferenceURL")]        public NSURL FileReferenceURL() { return default(NSURL); }                /// <summary>        /// Returns a new URL made by appending a path component to the original URL.        /// </summary>        /// <param name="pathComponent">The path component to add to the URL, in its original form (not URL encoded).</param>        [iOSVersion(4)]        public NSURL URLByAppendingPathComponent(string pathComponent) { return default(NSURL); }                /// <summary>        /// Returns a new URL made by appending a path component to the original URL, along with a trailing slash if the component is designated a directory.        /// </summary>        /// <param name="pathComponent">The path component to add to the URL.</param>        /// <param name="isDirectory">If true, a trailing slash is appended after pathComponent.</param>        [iOSVersion(5)]        public NSURL URLByAppendingPathComponent(string pathComponent, bool isDirectory) { return default(NSURL); }                /// <summary>        /// Returns a new URL made by appending a path extension to the original URL.        /// </summary>        /// <param name="pathExtension">The path extension to add to the URL.</param>        [iOSVersion(4)]        public NSURL URLByAppendingPathExtension(string pathExtension) { return default(NSURL); }                /// <summary>        /// Initializes and returns bookmark data derived from an alias file pointed to by a specified URL.        /// </summary>        /// <param name="bookmarkFileURL">The URL that points to the alias file.</param>        /// <param name="error">The error that occurred in the case that the bookmark data cannot be derived.</param>        [iOSVersion(5)]        [Export("bookmarkDataWithContentsOfURL")]        public static NSData BookmarkDataWithContentsOfURL(NSURL bookmarkFileURL, NSErrorPointer error) { return default(NSData); }                /// <summary>        /// Returns a bookmark for the URL, created with specified options and resource values.        /// </summary>        /// <param name="options">Options taken into account when creating the bookmark for the URL. The possible flags (which can be combined with bitwise OR operations) are described in Bookmark Data Creation Options.        ///   To create a security-scoped bookmark to support App Sandbox, include the NSURLBookmarkCreationWithSecurityScope flag. When you later resolve the bookmark, you can use the resulting security-scoped URL to obtain read/write access to the file-system resource pointed to by the URL.        ///   If you instead want to create a security-scoped bookmark that, when resolved, enables you to obtain read-only access to a file-system resource, bitwise OR this parameter’s value with both the NSURLBookmarkCreationWithSecurityScope option and the NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess option.</param>        /// <param name="includingResourceValuesForKeys">An array of names of URL resource properties to store as part of the bookmark. You can later access these values (without resolving the bookmark) by calling the resourceValuesForKeys:fromBookmarkData: method.        ///   The values of these properties must be of a type that the bookmark generation code can serialize. Specifically, the values can contain any of the following primitive types:        ///   NSString or CFString        ///   NSData or CFData        ///   NSDate or CFDate        ///   NSNumber or CFNumber        ///   CFBoolean        ///   NSURL or CFURL        ///   kCFNull or NSNull        ///   CFUUID        ///   In addition, the properties can contain the following collection classes:        ///   NSArray or CFArray containing only the above primitive types        ///   NSDictionary or CFDictionary with NSString or CFString keys, in which all values contain only the above primitive types</param>        /// <param name="relativeToURL">The URL that the bookmark data will be relative to.        ///   If you are creating a security-scoped bookmark to support App Sandbox, use this parameter as follows:        ///   To create an app-scoped bookmark, use a value of nil.         ///   To create a document-scoped bookmark, use the absolute path (despite this parameter’s name) to the document file that is to own the new security-scoped bookmark.</param>        /// <param name="error">The error that occurred in the case that the bookmark data cannot be created.</param>        [iOSVersion(5)]        [Export("bookmarkDataWithOptions")]        public NSData BookmarkDataWithOptions(NSURLBookmarkCreationOptions options, AnyObject[] includingResourceValuesForKeys, NSURL relativeToURL, NSErrorPointer error) { return default(NSData); }                /// <summary>        /// Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data.        /// </summary>        /// <param name="keys">An array of names of URL resource properties. In addition to the standard, system-defined resource properties, you can also request any custom properties that you provided when you created the bookmark. See the bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error: method for details.</param>        /// <param name="fromBookmarkData">The bookmark data from which you want to retrieve resource values.</param>        [iOSVersion(5)]        [Export("resourceValuesForKeys")]        public static Dictionary<NSObject, AnyObject> ResourceValuesForKeys(AnyObject[] keys, NSData fromBookmarkData) { return default(Dictionary<NSObject, AnyObject>); }                /// <summary>        /// Creates an alias file on disk at a specified location with specified bookmark data.        /// </summary>        /// <param name="bookmarkData">The bookmark data containing information for the alias file.</param>        /// <param name="toURL">The desired location of the alias file.</param>        /// <param name="options">Options taken into account when creating the alias file.</param>        /// <param name="error">The error that occurred in the case that the alias file cannot be created.</param>        [iOSVersion(5)]        [Export("writeBookmarkData")]        public static bool WriteBookmarkData(NSData bookmarkData, NSURL toURL, NSURLBookmarkFileCreationOptions options, NSErrorPointer error) { return default(bool); }                /// <summary>        /// In an app that has adopted App Sandbox, makes the resource pointed to by a security-scoped URL available to the app.        /// </summary>        [iOSVersion(8)]        [Export("startAccessingSecurityScopedResource")]        public bool StartAccessingSecurityScopedResource() { return default(bool); }                /// <summary>        /// In an app that adopts App Sandbox, revokes access to the resource pointed to by a security-scoped URL.        /// </summary>        [iOSVersion(8)]        [Export("stopAccessingSecurityScopedResource")]        public void StopAccessingSecurityScopedResource() {  }                /// <summary>        /// Returns the value of the resource property for the specified key.        /// </summary>        /// <param name="value">The location where the value for the resource property identified by key should be stored.</param>        /// <param name="forKey">The name of one of the URL’s resource properties.</param>        /// <param name="error">The error that occurred if the resource value could not be retrieved. This parameter is optional. If you are not interested in receiving error information, you can pass nil.</param>        [iOSVersion(5)]        [Export("getResourceValue")]        public bool GetResourceValue(AutoreleasingUnsafePointer<AnyObject> value, string forKey, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Returns the resource values for the properties identified by specified array of keys.        /// </summary>        /// <param name="keys">An array of property keys for the desired resource properties.</param>        /// <param name="error">The error that occurred if one or more resource values could not be retrieved.  This parameter is optional. If you are not interested in receiving error information, you can pass nil.</param>        [iOSVersion(5)]        [Export("resourceValuesForKeys")]        public Dictionary<NSObject, AnyObject> ResourceValuesForKeys(AnyObject[] keys, NSErrorPointer error) { return default(Dictionary<NSObject, AnyObject>); }                /// <summary>        /// Sets the URL’s resource property for a given key to a given value.        /// </summary>        /// <param name="value">The value for the resource property defined by key.</param>        /// <param name="forKey">The name of one of the URL’s resource properties.</param>        /// <param name="error">The error that occurred if the resource value could not be set.</param>        [iOSVersion(5)]        [Export("setResourceValue")]        public bool SetResourceValue(AnyObject value, string forKey, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Sets the URL’s resource properties for a given set of keys to a given set of values.        /// </summary>        /// <param name="keyedValues">A dictionary of resource values to be set.</param>        /// <param name="error">The error that occurred if one or more resource values could not be set.</param>        [iOSVersion(5)]        [Export("setResourceValues")]        public bool SetResourceValues(Dictionary<NSObject, AnyObject> keyedValues, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Removes all cached resource values and temporary resource values from the URL object.        /// </summary>        [iOSVersion(7)]        [Export("removeAllCachedResourceValues")]        public void RemoveAllCachedResourceValues() {  }                /// <summary>        /// Removes the cached resource value identified by a given key from the URL object.        /// </summary>        /// <param name="key">The resource value key whose cached values you want to remove.</param>        [iOSVersion(7)]        [Export("removeCachedResourceValueForKey")]        public void RemoveCachedResourceValueForKey(string key) {  }                /// <summary>        /// Sets a temporary resource value on the URL object.        /// </summary>        /// <param name="value">The value to store.</param>        /// <param name="forKey">The key where the value should be stored. This key must be unique and must not conflict with any system-defined keys. Reverse-domain-name notation is recommended.</param>        [iOSVersion(7)]        [Export("setTemporaryResourceValue")]        public void SetTemporaryResourceValue(AnyObject value, string forKey) {  }                /// <summary>        /// Returns whether the promised item can be reached.        /// </summary>        /// <param name="error">The error that occurred when the promised item could not be reached.</param>        [iOSVersion(8)]        [Export("checkPromisedItemIsReachableAndReturnError")]        public bool CheckPromisedItemIsReachableAndReturnError(NSErrorPointer error) { return default(bool); }                /// <summary>        /// Returns the value of the resource property for the specified key.        /// </summary>        /// <param name="value">The location where the value for the resource property identified by key should be stored.</param>        /// <param name="forKey">The name of one of the URL’s resource properties.</param>        /// <param name="error">The error that occurred in the case that the resource value cannot be retrieved.</param>        [iOSVersion(8)]        [Export("getPromisedItemResourceValue")]        public bool GetPromisedItemResourceValue(AutoreleasingUnsafePointer<AnyObject> value, string forKey, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Returns the resource values for the properties identified by specified array of keys.        /// </summary>        /// <param name="keys">An array of names of URL resource properties.</param>        /// <param name="error">The error that occurred in the case that one or more resource values cannot be retrieved.</param>        [iOSVersion(8)]        [Export("promisedItemResourceValuesForKeys")]        public Dictionary<NSObject, AnyObject> PromisedItemResourceValuesForKeys(AnyObject[] keys, NSErrorPointer error) { return default(Dictionary<NSObject, AnyObject>); }                /// <summary>        /// A boolean value that determines whether the receiver is a file URL. (read-only)        /// </summary>        [iOSVersion(8)]        [Export("fileURL")]        public bool FileURL { get; private set; }                /// <summary>        /// The URL string for the receiver as an absolute URL. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("absoluteString")]        public string AbsoluteString { get; private set; }                /// <summary>        /// An absolute URL that refers to the same resource as the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("absoluteURL")]        public NSURL AbsoluteURL { get; private set; }                /// <summary>        /// The base URL. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("baseURL")]        public NSURL BaseURL { get; private set; }                /// <summary>        /// A C string containing the URL’s file system path. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("fileSystemRepresentation")]        public ConstUnsafePointer<Int8> FileSystemRepresentation { get; private set; }                /// <summary>        /// The fragment identifier, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("fragment")]        public string Fragment { get; private set; }                /// <summary>        /// The host, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("host")]        public string Host { get; private set; }                /// <summary>        /// The last path component. (read-only)        /// </summary>        [iOSVersion(4)]        [Export("lastPathComponent")]        public string LastPathComponent { get; private set; }                /// <summary>        /// The parameter string conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("parameterString")]        public string ParameterString { get; private set; }                /// <summary>        /// The password conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("password")]        public string Password { get; private set; }                /// <summary>        /// The path, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("path")]        public string Path { get; private set; }                /// <summary>        /// An array containing the  path components. (read-only)        /// </summary>        [iOSVersion(4)]        [Export("pathComponents")]        public AnyObject[] PathComponents { get; private set; }                /// <summary>        /// The path extension. (read-only)        /// </summary>        [iOSVersion(4)]        [Export("pathExtension")]        public string PathExtension { get; private set; }                /// <summary>        /// The port, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("port")]        public NSNumber Port { get; private set; }                /// <summary>        /// The query string, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("query")]        public string Query { get; private set; }                /// <summary>        /// The relative path, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("relativePath")]        public string RelativePath { get; private set; }                /// <summary>        /// A string representation of the relative portion of the URL. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("relativeString")]        public string RelativeString { get; private set; }                /// <summary>        /// The resource specifier. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("resourceSpecifier")]        public string ResourceSpecifier { get; private set; }                /// <summary>        /// The scheme. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("scheme")]        public string Scheme { get; private set; }                /// <summary>        /// A copy of the URL with any instances of &quot;..&quot; or &quot;.&quot; removed from its path. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("standardizedURL")]        public NSURL StandardizedURL { get; private set; }                /// <summary>        /// The user name, conforming to RFC 1808. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("user")]        public string User { get; private set; }                /// <summary>        /// A file path URL that points to the same resource as the URL object. (read-only)        /// </summary>        [iOSVersion(5)]        [Export("filePathURL")]        public NSURL FilePathURL { get; private set; }                /// <summary>        /// A URL created by taking the receiver and removing the last path component. (read-only)        /// </summary>        [iOSVersion(4)]        public NSURL URLByDeletingLastPathComponent { get; private set; }                /// <summary>        /// A URL created by taking the receiver and removing the path extension, if any. (read-only)        /// </summary>        [iOSVersion(4)]        public NSURL URLByDeletingPathExtension { get; private set; }                /// <summary>        /// A URL that points to the same resource as the receiver and includes no symbolic links. (read-only)        /// </summary>        [iOSVersion(4)]        public NSURL URLByResolvingSymlinksInPath { get; private set; }                /// <summary>        /// A URL that points to the same resource as the original URL using an absolute path. (read-only)        /// </summary>        [iOSVersion(4)]        public NSURL URLByStandardizingPath { get; private set; }                /// <summary>        /// These schemes are the ones that NSURL can parse.        /// </summary>        public string NSURLFileScheme { get; set; }    }    /// <summary>    /// Options used when creating bookmark data.    /// </summary>    [iOSVersion(4)]    public enum NSURLBookmarkCreationOptions    {        /// <summary>        /// Specifies that when a bookmark created with this option is resolved, its embedded file ID should take precedence over other sources of information (file system path, for example) in the event of a conflict.        /// Available in iOS 4.0 and later.        /// Deprecated in iOS 7.0.        /// </summary>        [Obsolete]        PreferFileIDResolution,        /// <summary>        /// Specifies that a bookmark created with this option should be created with minimal information. This produces a smaller bookmark that can be resolved in fewer ways.        /// </summary>        [iOSVersion(4)]        MinimalBookmark,        /// <summary>        /// Specifies that the bookmark data should include properties required to create Finder alias files.        /// </summary>        [iOSVersion(4)]        SuitableForBookmarkFile,        /// <summary>        ///         /// </summary>        WithSecurityScope,        /// <summary>        ///         /// </summary>        SecurityScopeAllowOnlyReadAccess,    }    /// <summary>    /// Options used when resolving bookmark data.    /// </summary>    [iOSVersion(4)]    public enum NSURLBookmarkResolutionOptions    {        /// <summary>        /// Specifies that no UI feedback should accompany resolution of the bookmark data.        /// </summary>        [iOSVersion(4)]        WithoutUI,        /// <summary>        /// Specifies that no volume should be mounted during resolution of the bookmark data.        /// </summary>        [iOSVersion(4)]        WithoutMounting,        /// <summary>        ///         /// </summary>        WithSecurityScope,    }    /// <summary>    /// Options used when creating file bookmark data    /// </summary>    [iOSVersion(4)]    public struct NSURLBookmarkFileCreationOptions    {        static public implicit operator NSURLBookmarkFileCreationOptions(int value)        {            return default(NSURLBookmarkFileCreationOptions);        }        static public implicit operator int(NSURLBookmarkFileCreationOptions value)        {            return default(int);        }    }}